import { Controller, Get, Post, Put, Param, Body, HttpStatus, HttpException, Logger } from '@nestjs/common';
import { PentestService } from '../services/pentest.service';
import { PentestSchedule, PentestStatus } from '../entities/pentest-schedule.entity';

@Controller('security/pentests')
export class PentestController {
  private readonly logger = new Logger(PentestController.name);

  constructor(private readonly pentestService: PentestService) {}

  @Get()
  async getAllSchedules() {
    try {
      return await this.pentestService.getAllSchedules();
    } catch (error) {
      this.logger.error(`Error fetching all pentest schedules: ${error.message}`);
      throw new HttpException('Failed to retrieve pentest schedules', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Get('upcoming')
  async getUpcomingPentests() {
    try {
      return await this.pentestService.getUpcomingPentests();
    } catch (error) {
      this.logger.error(`Error fetching upcoming pentests: ${error.message}`);
      throw new HttpException('Failed to retrieve upcoming pentests', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Get('active')
  async getActiveTests() {
    try {
      return await this.pentestService.getActiveTests();
    } catch (error) {
      this.logger.error(`Error fetching active pentests: ${error.message}`);
      throw new HttpException('Failed to retrieve active pentests', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Post()
  async createPentestSchedule(@Body() scheduleData: Partial<PentestSchedule>) {
    try {
      return await this.pentestService.createPentestSchedule(scheduleData);
    } catch (error) {
      this.logger.error(`Error creating pentest schedule: ${error.message}`);
      throw new HttpException(
        `Failed to create pentest schedule: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Put(':id/status')
  async updatePentestStatus(
    @Param('id') id: string,
    @Body() statusData: { status: PentestStatus; additionalData?: Partial<PentestSchedule> }
  ) {
    try {
      return await this.pentestService.updatePentestStatus(
        id,
        statusData.status,
        statusData.additionalData
      );
    } catch (error) {
      this.logger.error(`Error updating pentest status for ${id}: ${error.message}`);
      throw new HttpException(
        `Failed to update pentest status: ${error.message}`,
        error.message.includes('not found') ? HttpStatus.NOT_FOUND : HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get(':id/scope')
  async generatePentestScope(@Param('id') id: string) {
    try {
      const scopeDocument = await this.pentestService.generatePentestScope(id);
      return { scope: scopeDocument };
    } catch (error) {
      this.logger.error(`Error generating pentest scope for ${id}: ${error.message}`);
      throw new HttpException(
        `Failed to generate pentest scope: ${error.message}`,
        error.message.includes('not found') ? HttpStatus.NOT_FOUND : HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Post('check-upcoming')
  async checkUpcomingPentests() {
    try {
      await this.pentestService.checkUpcomingPentests();
      return { message: 'Upcoming pentests checked and notifications sent if needed' };
    } catch (error) {
      this.logger.error(`Error checking upcoming pentests: ${error.message}`);
      throw new HttpException('Failed to check upcoming pentests', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
}