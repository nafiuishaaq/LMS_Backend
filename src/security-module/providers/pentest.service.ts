import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, LessThan, MoreThan } from 'typeorm';
import { PentestSchedule, PentestStatus, PentestType } from '../entities/pentest-schedule.entity';
import { NotificationService } from './notification.service';

@Injectable()
export class PentestService {
  private readonly logger = new Logger(PentestService.name);

  constructor(
    @InjectRepository(PentestSchedule)
    private pentestScheduleRepository: Repository<PentestSchedule>,
    private readonly notificationService: NotificationService,
  ) {}

  async createPentestSchedule(scheduleData: Partial<PentestSchedule>): Promise<PentestSchedule> {
    try {
      const schedule = this.pentestScheduleRepository.create(scheduleData);
      return await this.pentestScheduleRepository.save(schedule);
    } catch (error) {
      this.logger.error(`Error creating pentest schedule: ${error.message}`, error.stack);
      throw error;
    }
  }

  async getAllSchedules(): Promise<PentestSchedule[]> {
    return this.pentestScheduleRepository.find({
      order: {
        scheduledStartDate: 'DESC',
      },
    });
  }

  async getUpcomingPentests(): Promise<PentestSchedule[]> {
    const now = new Date();
    return this.pentestScheduleRepository.find({
      where: {
        scheduledStartDate: MoreThan(now),
        status: PentestStatus.SCHEDULED,
      },
      order: {
        scheduledStartDate: 'ASC',
      },
    });
  }

  async getActiveTests(): Promise<PentestSchedule[]> {
    const now = new Date();
    return this.pentestScheduleRepository.find({
      where: {
        scheduledStartDate: LessThan(now),
        scheduledEndDate: MoreThan(now),
        status: PentestStatus.IN_PROGRESS,
      },
    });
  }

  async updatePentestStatus(id: string, status: PentestStatus, additionalData?: Partial<PentestSchedule>): Promise<PentestSchedule> {
    const pentest = await this.pentestScheduleRepository.findOne({ where: { id } });
    
    if (!pentest) {
      throw new Error(`Pentest schedule with ID ${id} not found`);
    }
    
    pentest.status = status;
    
    // Update actual start/end dates based on status
    if (status === PentestStatus.IN_PROGRESS && !pentest.actualStartDate) {
      pentest.actualStartDate = new Date();
    }
    
    if ((status === PentestStatus.COMPLETED) && !pentest.actualEndDate) {
      pentest.actualEndDate = new Date();
    }
    
    // Apply any additional updates
    if (additionalData) {
      Object.assign(pentest, additionalData);
    }
    
    return await this.pentestScheduleRepository.save(pentest);
  }

  async generatePentestScope(pentestId: string): Promise<string> {
    const pentest = await this.pentestScheduleRepository.findOne({ where: { id: pentestId } });
    
    if (!pentest) {
      throw new Error(`Pentest schedule with ID ${pentestId} not found`);
    }
    
    // Generate a formatted scope document
    let scopeDoc = `# Penetration Test Scope Document\n\n`;
    scopeDoc += `## Test Information\n`;
    scopeDoc += `- Test ID: ${pentest.id}\n`;
    scopeDoc += `- Title: ${pentest.title}\n`;
    scopeDoc += `- Type: ${pentest.type}\n`;
    scopeDoc += `- Scheduled Period: ${pentest.scheduledStartDate.toISOString().split('T')[0]} to ${pentest.scheduledEndDate.toISOString().split('T')[0]}\n`;
    
    if (pentest.pentesterName) {
      scopeDoc += `- Assigned Pentester: ${pentest.pentesterName}\n`;
    }
    
    scopeDoc += `\n## Scope Components\n`;
    if (pentest.scopeComponents && pentest.scopeComponents.length > 0) {
      pentest.scopeComponents.forEach(component => {
        scopeDoc += `- ${component}\n`;
      });
    } else {
      scopeDoc += `- No specific components defined\n`;
    }
    
    scopeDoc += `\n## Excluded Items\n`;
    if (pentest.excludedComponents && pentest.excludedComponents.length > 0) {
      pentest.excludedComponents.forEach(component => {
        scopeDoc += `- ${component}\n`;
      });
    } else {
      scopeDoc += `- No specific exclusions defined\n`;
    }
    
    scopeDoc += `\n## Test Methodology\n`;
    // Add test methodology based on type
    switch (pentest.type) {
      case PentestType.APPLICATION:
        scopeDoc += `- OWASP Top 10 vulnerabilities\n`;
        scopeDoc += `- Business logic testing\n`;
        scopeDoc += `- Authentication and authorization testing\n`;
        scopeDoc += `- Session management testing\n`;
        scopeDoc += `- Input validation testing\n`;
        break;
      case PentestType.API:
        scopeDoc += `- OWASP API Security Top 10\n`;
        scopeDoc += `- Authentication mechanisms\n`;
        scopeDoc += `- Rate limiting and throttling\n`;
        scopeDoc += `- Data validation\n`;
        break;
      case PentestType.NETWORK:
        scopeDoc += `- Network device enumeration\n`;
        scopeDoc += `- Service identification\n`;
        scopeDoc += `- Vulnerability scanning\n`;
        scopeDoc += `- Exploitation attempts\n`;
        break;
      default:
        scopeDoc += `- Standard methodology for ${pentest.type} testing\n`;
    }
    
    scopeDoc += `\n## Reporting Requirements\n`;
    scopeDoc += `- Detailed findings with evidence\n`;
    scopeDoc += `- Severity classifications\n`;
    scopeDoc += `- Remediation recommendations\n`;
    scopeDoc += `- Executive summary\n`;
    
    return scopeDoc;
  }

  async checkUpcomingPentests(): Promise<void> {
    try {
      const now = new Date();
      const oneWeekFromNow = new Date();
      oneWeekFromNow.setDate(now.getDate() + 7);
      
      // Find pentests starting within the next week
      const upcomingPentests = await this.pentestScheduleRepository.find({
        where: {
          scheduledStartDate: MoreThan(now),
          scheduledStartDate: LessThan(oneWeekFromNow),
          status: PentestStatus.SCHEDULED,
          notificationSent: false,
        },
      });
      
      // Send notifications for each upcoming pentest
      for (const pentest of upcomingPentests) {
        await this.notificationService.sendPentestReminder({
          pentestId: pentest.id,
          title: pentest.title,
          startDate: pentest.scheduledStartDate,
          type: pentest.type,
          pentesterName: pentest.pentesterName,
        });
        
        // Update notification status
        pentest.notificationSent = true;
        await this.pentestScheduleRepository.save(pentest);
      }
      
      // Check for tests that should be starting today
      const startingToday = await this.pentestScheduleRepository.find({
        where: {
          scheduledStartDate: LessThan(new Date(now.setHours(23, 59, 59, 999))),
          scheduledStartDate: MoreThan(new Date(now.setHours(0, 0, 0, 0))),
          status: PentestStatus.SCHEDULED,
        },
      });
      
      // Update their status and send notifications
      for (const pentest of startingToday) {
        await this.updatePentestStatus(pentest.id, PentestStatus.IN_PROGRESS);
        
        await this.notificationService.sendPentestStartNotification({
          pentestId: pentest.id,
          title: pentest.title,
          type: pentest.type,
        });
      }
      
    } catch (error) {
      this.logger.error(`Error checking upcoming pentests: ${error.message}`, error.stack);
      throw error;
    }
  }
}
